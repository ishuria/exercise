3.1.6
1.d
2.d
3.b
4.a
5.a
6.c
7.c
8.a
9.a
10.d
11.c
12.b
13.d
14.a
15.d
16.a
17.b
18.b
19.a
20.c
21.d
22.b
23.a
24.b
25.c
26.d
27.bc
28.d
29.a
30.a
31.b
32.d
33.b
34.c
35.b
36.c
37.b
38.c
39.b
40.a
41.a
42.c
43.b
44.d
45.a
46.c
47.a
48.a
49.d
50.c


3.2.9
1.c
2.b
3.b
4.d
5.d
6.b
7.c
8.c
9.b
10.d
11.c
12.d
13.d
14.b
15.
16.d
17.a
18.d
19.c
20.b
21.b
22.c
23.d
24.b
25.b
26.c
27.c
28.c
29.c
30.b
31.d
32.b
33.a
34.c
35.a
36.a
37.a
38.
39.d








请求分页系统中页面分配策略与页面置换策略的关系
@(OS)

回顾几种分配策略：

固定分区分配
动态分区分配
伙伴系统
可重定位分区分配
页面置换策略：

全局置换
局部置换
其中，关于分区分配策略已经很熟悉了，需要特别说明的是页面置换策略。这是我们在课本上不太强调的。

局部置换只置换本进程内的物理页面。一个进程占用的物理页面总数是限定的，当需要置换时，即总数已经用完，新进来一个页面，本进程就需要出去一个老的页面。所谓，朋友圈就那么大，有人进来自然需要有人出去。但是需要注意的是，如果分配给你的总数还没用完，自然是不用置换的，那是最初的红利时期，竞争还不激烈，先到先得。

全局置换指的是进程缺页时，可能置换的是内存中所有可换出的物理页面。即要换进的是A进程的页面，出去的可以是B进程的页面，因此分配给进程的页面总数是动态变化的。

这两种总的置换策略下有各自的方法：

局部置换：

最优算法
先进先出算法(有Belady异常)
Least Recently Used(最近最久未使用算法)
时钟算法
最不常用算法(Least Frequently Used)算法
全局置换：

工作集算法
缺页率算法
（2015.30） 请求分页系统中，页面分配策略和页面置换策略不能组合使用的是：C––C_ 
A. 可变分配，全局置换 
B. 可变分配，局部置换 
C. 固定分配，全局置换 
D. 固定分配，局部置换

固定分配：将内存用户空间划分为多个固定大小的区域，在每个分区中只装入一个作业。 
划分分区的方法有两种：

分区大小相等
分区大小不等
内存分配方法：按照分区大小建立分区使用表。记录每个分区的起始地址，大小和状态。 
因此，固定分配不可能实现跨越进程的页面分配，个人自扫门前雪类型。

动态分区分配：根据进程的实际需要，动态地为之分配内存空间。 
这句话不可以简单跳过，根据的是进程的需要，进程是动态的，是一次静态程序的执行过程。

为了实现这个，需要建立空闲分区表和空闲分区链。空闲分区表自然也是记录分区区号，分区起始地址和大小等。分区可以是离散的，因此需要链表来维护分区之间的关系。

分配内存：根据某种分配算法(首次适应，循环首次适应，最佳适应，最坏适应，快速适应等)，从空闲分区链中找到需要的分区，根据一个算式： 
m.size−u.size≤sizem.size−u.size≤size,其中m.size是每个空闲分区的大小，u.size是请求的分区大小，size是规定的不可再切割的剩余分区的大小。即，如果分配完以后，剩余部分小于size这条线了，那么就把整个分区给你，否则，你只能拿到你所需要的。也即是超过一定量的交易额是大客户，待遇要好于小客户。

从这个过程中我们可以看到，空闲分区没有属于哪个进程的概念，即大家是吃大锅饭的。则在实现分页系统时，可以实现全局分配。局部分配是基础配置，自然不必多说。

因此，C项是无法组合在一起使用的。